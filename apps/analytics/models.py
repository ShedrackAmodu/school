# apps/analytics/models.py

from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from django.utils.translation import gettext_lazy as _
from apps.core.models import CoreBaseModel
from apps.academics.models import AcademicSession
from django.utils import timezone


class ReportType(CoreBaseModel):
    """
    Model for defining different types of analytics reports.
    """
    class ReportCategory(models.TextChoices):
        ACADEMIC = 'academic', _('Academic')
        FINANCIAL = 'financial', _('Financial')
        ATTENDANCE = 'attendance', _('Attendance')
        LIBRARY = 'library', _('Library')
        TRANSPORT = 'transport', _('Transport')
        STAFF = 'staff', _('Staff')
        STUDENT = 'student', _('Student')
        SYSTEM = 'system', _('System')

    name = models.CharField(_('report type name'), max_length=100)
    code = models.SlugField(_('report code'), max_length=50, unique=True)
    category = models.CharField(
        _('category'),
        max_length=20,
        choices=ReportCategory.choices
    )
    description = models.TextField(_('description'), blank=True)
    data_source = models.CharField(_('data source'), max_length=200)
    is_standard = models.BooleanField(_('is standard report'), default=True)
    parameters_schema = models.JSONField(_('parameters schema'), default=dict, blank=True)
    refresh_frequency = models.CharField(
        _('refresh frequency'),
        max_length=20,
        choices=[
            ('realtime', _('Real-time')),
            ('daily', _('Daily')),
            ('weekly', _('Weekly')),
            ('monthly', _('Monthly')),
            ('quarterly', _('Quarterly')),
            ('yearly', _('Yearly')),
            ('manual', _('Manual'))
        ],
        default='manual'
    )
    access_roles = models.JSONField(_('access roles'), default=list, blank=True)

    class Meta:
        verbose_name = _('Report Type')
        verbose_name_plural = _('Report Types')
        ordering = ['category', 'name']
        indexes = [
            models.Index(fields=['category', 'is_standard']),
            models.Index(fields=['code', 'status']),
        ]

    def __str__(self):
        return f"{self.name} ({self.get_category_display()})"


class Report(CoreBaseModel):
    """
    Model for storing generated reports and their metadata.
    """
    class ReportFormat(models.TextChoices):
        HTML = 'html', _('HTML')
        PDF = 'pdf', _('PDF')
        EXCEL = 'excel', _('Excel')
        CSV = 'csv', _('CSV')
        JSON = 'json', _('JSON')

    class ReportStatus(models.TextChoices):
        PENDING = 'pending', _('Pending')
        GENERATING = 'generating', _('Generating')
        COMPLETED = 'completed', _('Completed')
        FAILED = 'failed', _('Failed')
        EXPIRED = 'expired', _('Expired')

    report_type = models.ForeignKey(
        ReportType,
        on_delete=models.CASCADE,
        related_name='reports',
        verbose_name=_('report type')
    )
    name = models.CharField(_('report name'), max_length=200)
    academic_session = models.ForeignKey(
        AcademicSession,
        on_delete=models.CASCADE,
        related_name='analytics_reports',
        verbose_name=_('academic session')
    )
    generated_by = models.ForeignKey(
        'users.User',
        on_delete=models.SET_NULL,
        null=True,
        related_name='analytics_reports',
        verbose_name=_('generated by')
    )
    parameters = models.JSONField(_('report parameters'), default=dict, blank=True)
    format = models.CharField(
        _('report format'),
        max_length=10,
        choices=ReportFormat.choices,
        default=ReportFormat.HTML
    )
    status = models.CharField(
        _('report status'),
        max_length=20,
        choices=ReportStatus.choices,
        default=ReportStatus.PENDING
    )
    file = models.FileField(
        _('report file'),
        upload_to='reports/%Y/%m/%d/',
        null=True,
        blank=True
    )
    data = models.JSONField(_('report data'), default=dict, blank=True)
    summary = models.TextField(_('report summary'), blank=True)
    generation_started_at = models.DateTimeField(_('generation started at'), null=True, blank=True)
    generation_completed_at = models.DateTimeField(_('generation completed at'), null=True, blank=True)
    expires_at = models.DateTimeField(_('expires at'), null=True, blank=True)
    access_count = models.PositiveIntegerField(_('access count'), default=0)
    last_accessed_at = models.DateTimeField(_('last accessed at'), null=True, blank=True)

    class Meta:
        verbose_name = _('Report')
        verbose_name_plural = _('Reports')
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['report_type', 'academic_session']),
            models.Index(fields=['status', 'created_at']),
            models.Index(fields=['generated_by', 'created_at']),
        ]

    def __str__(self):
        return f"{self.name} - {self.get_status_display()}"

    def mark_accessed(self):
        """Increment access count and update last accessed timestamp."""
        self.access_count += 1
        self.last_accessed_at = timezone.now()
        self.save(update_fields=['access_count', 'last_accessed_at'])

    @property
    def generation_duration(self):
        """Calculate report generation duration in seconds."""
        if self.generation_started_at and self.generation_completed_at:
            return (self.generation_completed_at - self.generation_started_at).total_seconds()
        return None


class Dashboard(CoreBaseModel):
    """
    Model for user-customizable analytics dashboards.
    """
    class DashboardType(models.TextChoices):
        SYSTEM = 'system', _('System Default')
        USER = 'user', _('User Custom')
        ROLE = 'role', _('Role Specific')

    name = models.CharField(_('dashboard name'), max_length=100)
    description = models.TextField(_('description'), blank=True)
    dashboard_type = models.CharField(
        _('dashboard type'),
        max_length=20,
        choices=DashboardType.choices,
        default=DashboardType.USER
    )
    owner = models.ForeignKey(
        'users.User',
        on_delete=models.CASCADE,
        related_name='dashboards',
        verbose_name=_('owner')
    )
    layout_config = models.JSONField(_('layout configuration'), default=dict)
    widget_config = models.JSONField(_('widget configuration'), default=dict)
    is_default = models.BooleanField(_('is default dashboard'), default=False)
    refresh_interval = models.PositiveIntegerField(
        _('refresh interval in minutes'),
        default=15,
        validators=[MinValueValidator(1), MaxValueValidator(1440)]
    )
    access_roles = models.JSONField(_('access roles'), default=list, blank=True)

    class Meta:
        verbose_name = _('Dashboard')
        verbose_name_plural = _('Dashboards')
        ordering = ['name']
        unique_together = ['owner', 'name']
        indexes = [
            models.Index(fields=['owner', 'is_default']),
            models.Index(fields=['dashboard_type', 'status']),
        ]

    def __str__(self):
        return f"{self.name} - {self.owner}"

    def save(self, *args, **kwargs):
        """
        Ensure only one default dashboard per user.
        """
        if self.is_default:
            Dashboard.objects.filter(owner=self.owner, is_default=True).update(is_default=False)
        super().save(*args, **kwargs)


class KPI(CoreBaseModel):
    """
    Model for Key Performance Indicators tracking.
    """
    class KPICategory(models.TextChoices):
        ACADEMIC = 'academic', _('Academic')
        FINANCIAL = 'financial', _('Financial')
        OPERATIONAL = 'operational', _('Operational')
        STUDENT = 'student', _('Student Performance')
        STAFF = 'staff', _('Staff Performance')
        SYSTEM = 'system', _('System Usage')

    class ValueType(models.TextChoices):
        PERCENTAGE = 'percentage', _('Percentage')
        NUMBER = 'number', _('Number')
        CURRENCY = 'currency', _('Currency')
        DURATION = 'duration', _('Duration')
        RATIO = 'ratio', _('Ratio')

    name = models.CharField(_('KPI name'), max_length=100)
    code = models.SlugField(_('KPI code'), max_length=50, unique=True)
    category = models.CharField(
        _('category'),
        max_length=20,
        choices=KPICategory.choices
    )
    description = models.TextField(_('description'), blank=True)
    value_type = models.CharField(
        _('value type'),
        max_length=20,
        choices=ValueType.choices,
        default=ValueType.NUMBER
    )
    target_value = models.DecimalField(
        _('target value'),
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True
    )
    min_value = models.DecimalField(
        _('minimum value'),
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True
    )
    max_value = models.DecimalField(
        _('maximum value'),
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True
    )
    calculation_query = models.TextField(_('calculation query'), blank=True)
    data_source = models.CharField(_('data source'), max_length=200)
    refresh_frequency = models.CharField(
        _('refresh frequency'),
        max_length=20,
        choices=[
            ('realtime', _('Real-time')),
            ('hourly', _('Hourly')),
            ('daily', _('Daily')),
            ('weekly', _('Weekly')),
            ('monthly', _('Monthly'))
        ],
        default='daily'
    )
    is_trending = models.BooleanField(_('show trending'), default=True)
    display_format = models.CharField(_('display format'), max_length=100, blank=True)

    class Meta:
        verbose_name = _('Key Performance Indicator')
        verbose_name_plural = _('Key Performance Indicators')
        ordering = ['category', 'name']
        indexes = [
            models.Index(fields=['category', 'status']),
            models.Index(fields=['code', 'refresh_frequency']),
        ]

    def __str__(self):
        return f"{self.name} ({self.get_category_display()})"


class KPIMeasurement(CoreBaseModel):
    """
    Model for storing historical KPI measurements.
    """
    kpi = models.ForeignKey(
        KPI,
        on_delete=models.CASCADE,
        related_name='measurements',
        verbose_name=_('KPI')
    )
    academic_session = models.ForeignKey(
        AcademicSession,
        on_delete=models.CASCADE,
        related_name='kpi_measurements',
        verbose_name=_('academic session')
    )
    measured_at = models.DateTimeField(_('measured at'), db_index=True)
    value = models.DecimalField(
        _('measured value'),
        max_digits=10,
        decimal_places=2
    )
    previous_value = models.DecimalField(
        _('previous value'),
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True
    )
    change_percentage = models.DecimalField(
        _('change percentage'),
        max_digits=6,
        decimal_places=2,
        null=True,
        blank=True
    )
    metadata = models.JSONField(_('measurement metadata'), default=dict, blank=True)

    class Meta:
        verbose_name = _('KPI Measurement')
        verbose_name_plural = _('KPI Measurements')
        ordering = ['-measured_at']
        indexes = [
            models.Index(fields=['kpi', 'measured_at']),
            models.Index(fields=['academic_session', 'measured_at']),
        ]
        unique_together = ['kpi', 'measured_at']

    def __str__(self):
        return f"{self.kpi.name} - {self.measured_at.date()}"

    def save(self, *args, **kwargs):
        """
        Calculate change percentage if previous value exists.
        """
        if self.previous_value and self.previous_value != 0:
            self.change_percentage = ((self.value - self.previous_value) / abs(self.previous_value)) * 100
        super().save(*args, **kwargs)


class DataExport(CoreBaseModel):
    """
    Model for tracking data export requests and results.
    """
    class ExportStatus(models.TextChoices):
        PENDING = 'pending', _('Pending')
        PROCESSING = 'processing', _('Processing')
        COMPLETED = 'completed', _('Completed')
        FAILED = 'failed', _('Failed')
        CANCELLED = 'cancelled', _('Cancelled')

    class ExportFormat(models.TextChoices):
        EXCEL = 'excel', _('Excel')
        CSV = 'csv', _('CSV')
        JSON = 'json', _('JSON')
        PDF = 'pdf', _('PDF')

    requested_by = models.ForeignKey(
        'users.User',
        on_delete=models.CASCADE,
        related_name='data_exports',
        verbose_name=_('requested by')
    )
    name = models.CharField(_('export name'), max_length=200)
    description = models.TextField(_('description'), blank=True)
    data_source = models.CharField(_('data source'), max_length=200)
    filters = models.JSONField(_('export filters'), default=dict, blank=True)
    columns = models.JSONField(_('selected columns'), default=list, blank=True)
    format = models.CharField(
        _('export format'),
        max_length=10,
        choices=ExportFormat.choices,
        default=ExportFormat.EXCEL
    )
    status = models.CharField(
        _('export status'),
        max_length=20,
        choices=ExportStatus.choices,
        default=ExportStatus.PENDING
    )
    file = models.FileField(
        _('export file'),
        upload_to='exports/%Y/%m/%d/',
        null=True,
        blank=True
    )
    file_size = models.PositiveIntegerField(_('file size in bytes'), null=True, blank=True)
    record_count = models.PositiveIntegerField(_('record count'), null=True, blank=True)
    started_at = models.DateTimeField(_('started at'), null=True, blank=True)
    completed_at = models.DateTimeField(_('completed at'), null=True, blank=True)
    error_message = models.TextField(_('error message'), blank=True)
    expires_at = models.DateTimeField(_('expires at'), null=True, blank=True)

    class Meta:
        verbose_name = _('Data Export')
        verbose_name_plural = _('Data Exports')
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['requested_by', 'status']),
            models.Index(fields=['status', 'created_at']),
        ]

    def __str__(self):
        return f"{self.name} - {self.get_status_display()}"

    @property
    def processing_duration(self):
        """Calculate export processing duration in seconds."""
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None

    @property
    def file_size_human(self):
        """Return human-readable file size."""
        if not self.file_size:
            return "0 B"
        
        size = self.file_size
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} TB"


class AnalyticsCache(CoreBaseModel):
    """
    Model for caching frequently accessed analytics data.
    """
    cache_key = models.CharField(_('cache key'), max_length=255, unique=True, db_index=True)
    data = models.JSONField(_('cached data'))
    data_source = models.CharField(_('data source'), max_length=200)
    expires_at = models.DateTimeField(_('expires at'), db_index=True)
    last_accessed = models.DateTimeField(_('last accessed'), auto_now=True)
    access_count = models.PositiveIntegerField(_('access count'), default=0)
    size_bytes = models.PositiveIntegerField(_('size in bytes'))

    class Meta:
        verbose_name = _('Analytics Cache')
        verbose_name_plural = _('Analytics Cache')
        ordering = ['-last_accessed']
        indexes = [
            models.Index(fields=['cache_key', 'expires_at']),
            models.Index(fields=['expires_at', 'status']),
        ]

    def __str__(self):
        return f"{self.cache_key} - {self.expires_at}"

    def is_expired(self):
        """Check if cache entry has expired."""
        return timezone.now() > self.expires_at

    def mark_accessed(self):
        """Increment access count and update last accessed timestamp."""
        self.access_count += 1
        self.save(update_fields=['access_count', 'last_accessed'])


class TrendAnalysis(CoreBaseModel):
    """
    Model for storing trend analysis results.
    """
    class TrendDirection(models.TextChoices):
        UPWARD = 'upward', _('Upward')
        DOWNWARD = 'downward', _('Downward')
        STABLE = 'stable', _('Stable')
        VOLATILE = 'volatile', _('Volatile')

    name = models.CharField(_('analysis name'), max_length=200)
    description = models.TextField(_('description'), blank=True)
    data_source = models.CharField(_('data source'), max_length=200)
    analysis_period = models.CharField(
        _('analysis period'),
        max_length=20,
        choices=[
            ('daily', _('Daily')),
            ('weekly', _('Weekly')),
            ('monthly', _('Monthly')),
            ('quarterly', _('Quarterly')),
            ('yearly', _('Yearly'))
        ],
        default='monthly'
    )
    start_date = models.DateField(_('start date'))
    end_date = models.DateField(_('end date'))
    trend_direction = models.CharField(
        _('trend direction'),
        max_length=20,
        choices=TrendDirection.choices,
        default=TrendDirection.STABLE
    )
    confidence_score = models.DecimalField(
        _('confidence score'),
        max_digits=5,
        decimal_places=2,
        validators=[MinValueValidator(0), MaxValueValidator(100)]
    )
    key_findings = models.JSONField(_('key findings'), default=list, blank=True)
    recommendations = models.JSONField(_('recommendations'), default=list, blank=True)
    data_points = models.JSONField(_('data points'), default=list, blank=True)
    generated_by = models.ForeignKey(
        'users.User',
        on_delete=models.SET_NULL,
        null=True,
        related_name='trend_analyses',
        verbose_name=_('generated by')
    )
    generated_at = models.DateTimeField(_('generated at'), auto_now_add=True)

    class Meta:
        verbose_name = _('Trend Analysis')
        verbose_name_plural = _('Trend Analyses')
        ordering = ['-generated_at']
        indexes = [
            models.Index(fields=['start_date', 'end_date']),
            models.Index(fields=['trend_direction', 'confidence_score']),
        ]

    def __str__(self):
        return f"{self.name} - {self.get_trend_direction_display()}"

    @property
    def period_days(self):
        """Calculate analysis period in days."""
        return (self.end_date - self.start_date).days
